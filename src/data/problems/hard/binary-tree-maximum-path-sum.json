{
  "id": 12,
  "title": "Binary Tree Maximum Path Sum",
  "difficulty": "Hard",
  "company": [
    ""
  ],
  "tags": [
    "Dynamic Programming",
    "Tree",
    "Depth-First Search",
    "Binary Tree"
  ],
  "description": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return the **maximum path sum** of any non-empty path.\n\n### Example 1\n\n**Input:** `root = [1, 2, 3]`  \n**Output:** `6`  \n**Explanation:** The optimal path is `2 -> 1 -> 3` with a path sum of `2 + 1 + 3 = 6`.\n\n### Example 2\n\n**Input:** `root = [-10, 9, 20, null, null, 15, 7]`  \n**Output:** `42`  \n**Explanation:** The optimal path is `15 -> 20 -> 7` with a path sum of `15 + 20 + 7 = 42`.",
  "languages": {
    "python": {
      "starterCode": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef max_path_sum(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    # Your code here\n\n\n# Helper function to create a tree from a list\ndef create_tree(values):\n    if not values:\n        return None\n\n    root = TreeNode(values[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(values):\n        node = queue.pop(0)\n\n        # Left child\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n\n        # Right child\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n\n    return root\n\n# Test cases\nprint(max_path_sum(create_tree([1, 2, 3])))                      # Should return 6\nprint(max_path_sum(create_tree([-10, 9, 20, None, None, 15, 7]))) # Should return 42\nprint(max_path_sum(create_tree([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, 1]))) # Should return 48\nprint(max_path_sum(create_tree([-3])))                            # Should return -3"
    }
  }
}