{
  "id": 10,
  "title": "Serialize and Deserialize Binary Tree",
  "difficulty": "Hard",
  "company": [
    ""
  ],
  "tags": [
    "String",
    "Tree",
    "Depth-First Search",
    "Breadth-First Search",
    "Design",
    "Binary Tree"
  ],
  "description": "**Serialization** is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to **serialize and deserialize** a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n### Example 1\n\n**Input:** `root = [1, 2, 3, null, null, 4, 5]`  \n**Output:** `[1, 2, 3, null, null, 4, 5]`\n\n### Example 2\n\n**Input:** `root = []`  \n**Output:** `[]`",
  "languages": {
    "python": {
      "starterCode": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        # Your code here\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        # Your code here\n\n\n# Helper function to create a tree from a list\ndef create_tree(values):\n    if not values:\n        return None\n\n    root = TreeNode(values[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(values):\n        node = queue.pop(0)\n\n        # Left child\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n\n        # Right child\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n\n    return root\n\n# Helper function to convert a tree to a list\ndef tree_to_list(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n\n    # Remove trailing None values\n    while result and result[-1] is None:\n        result.pop()\n\n    return result\n\n# Test cases\ncodec = Codec()\n\n# Test case 1\nroot1 = create_tree([1, 2, 3, None, None, 4, 5])\nserialized1 = codec.serialize(root1)\ndeserialized1 = codec.deserialize(serialized1)\nprint(tree_to_list(deserialized1))  # Should return [1, 2, 3, None, None, 4, 5]\n\n# Test case 2\nroot2 = create_tree([])\nserialized2 = codec.serialize(root2)\ndeserialized2 = codec.deserialize(serialized2)\nprint(tree_to_list(deserialized2))  # Should return []"
    }
  }
}