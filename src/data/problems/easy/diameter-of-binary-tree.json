{
  "id": 28,
  "title": "Diameter of Binary Tree",
  "difficulty": "Easy",
  "company": [
    ""
  ],
  "tags": [
    "Tree",
    "Depth-First Search",
    "Binary Tree"
  ],
  "description": "Given the `root` of a binary tree, return the length of the **diameter** of the tree.\n\nThe **diameter** of a binary tree is the length of the **longest path** between any two nodes in a tree. This path may or may not pass through the root.\n\nThe length of a path between two nodes is represented by the number of edges between them.\n\n### Example 1\n\n**Input:** `root = [1, 2, 3, 4, 5]`  \n**Output:** `3`  \n**Explanation:** `3` is the length of the path `[4, 2, 1, 3]` or `[5, 2, 1, 3]`.\n\n### Example 2\n\n**Input:** `root = [1, 2]`  \n**Output:** `1`",
  "languages": {
    "python": {
      "starterCode": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameter_of_binary_tree(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    # Your code here\n\n\n# Helper function to create a tree from a list\ndef create_tree(values):\n    if not values:\n        return None\n\n    root = TreeNode(values[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(values):\n        node = queue.pop(0)\n\n        # Left child\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n\n        # Right child\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n\n    return root\n\n# Test cases\nprint(diameter_of_binary_tree(create_tree([1,2,3,4,5])))  # Should return 3\nprint(diameter_of_binary_tree(create_tree([1,2])))        # Should return 1\nprint(diameter_of_binary_tree(create_tree([1])))          # Should return 0"
    }
  }
}